// WARNING: Please don't edit this file. It was generated by C++/WinRT v2.0.220531.1

#pragma once
#ifndef WINRT_HL2MarkerTracking_H
#define WINRT_HL2MarkerTracking_H
#include "winrt/base.h"
static_assert(winrt::check_version(CPPWINRT_VERSION, "2.0.220531.1"), "Mismatched C++/WinRT headers.");
#define CPPWINRT_VERSION "2.0.220531.1"
#include "winrt/impl/Windows.Perception.Spatial.2.h"
#include "winrt/impl/HL2MarkerTracking.2.h"
namespace winrt::impl
{
    template <typename D> auto consume_HL2MarkerTracking_IMarkerTracker<D>::GetRawDepthMap() const
    {
        uint32_t result_impl_size{};
        uint16_t* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::HL2MarkerTracking::IMarkerTracker)->GetRawDepthMap(&result_impl_size, &result));
        return com_array<uint16_t>{ result, result_impl_size, take_ownership_from_abi };
    }
    template <typename D> auto consume_HL2MarkerTracking_IMarkerTracker<D>::GetProcessedDepthMap() const
    {
        uint32_t result_impl_size{};
        uint8_t* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::HL2MarkerTracking::IMarkerTracker)->GetProcessedDepthMap(&result_impl_size, &result));
        return com_array<uint8_t>{ result, result_impl_size, take_ownership_from_abi };
    }
    template <typename D> auto consume_HL2MarkerTracking_IMarkerTracker<D>::GetRawIrImage() const
    {
        uint32_t result_impl_size{};
        uint16_t* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::HL2MarkerTracking::IMarkerTracker)->GetRawIrImage(&result_impl_size, &result));
        return com_array<uint16_t>{ result, result_impl_size, take_ownership_from_abi };
    }
    template <typename D> auto consume_HL2MarkerTracking_IMarkerTracker<D>::GetProcessedIrImage() const
    {
        uint32_t result_impl_size{};
        uint8_t* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::HL2MarkerTracking::IMarkerTracker)->GetProcessedIrImage(&result_impl_size, &result));
        return com_array<uint8_t>{ result, result_impl_size, take_ownership_from_abi };
    }
    template <typename D> auto consume_HL2MarkerTracking_IMarkerTracker<D>::GetLfImage(int64_t& ts) const
    {
        uint32_t result_impl_size{};
        uint8_t* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::HL2MarkerTracking::IMarkerTracker)->GetLfImage(&ts, &result_impl_size, &result));
        return com_array<uint8_t>{ result, result_impl_size, take_ownership_from_abi };
    }
    template <typename D> auto consume_HL2MarkerTracking_IMarkerTracker<D>::GetRfImage(int64_t& ts) const
    {
        uint32_t result_impl_size{};
        uint8_t* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::HL2MarkerTracking::IMarkerTracker)->GetRfImage(&ts, &result_impl_size, &result));
        return com_array<uint8_t>{ result, result_impl_size, take_ownership_from_abi };
    }
    template <typename D> auto consume_HL2MarkerTracking_IMarkerTracker<D>::GetLrfImages(int64_t& ts_left, int64_t& ts_right) const
    {
        uint32_t result_impl_size{};
        uint8_t* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::HL2MarkerTracking::IMarkerTracker)->GetLrfImages(&ts_left, &ts_right, &result_impl_size, &result));
        return com_array<uint8_t>{ result, result_impl_size, take_ownership_from_abi };
    }
    template <typename D> auto consume_HL2MarkerTracking_IMarkerTracker<D>::SetROI(int32_t x, int32_t y, int32_t w) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::HL2MarkerTracking::IMarkerTracker)->SetROI(x, y, w));
    }
    template <typename D> auto consume_HL2MarkerTracking_IMarkerTracker<D>::SetDevicePose(array_view<float const> pose) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::HL2MarkerTracking::IMarkerTracker)->SetDevicePose(pose.size(), get_abi(pose)));
    }
    template <typename D> auto consume_HL2MarkerTracking_IMarkerTracker<D>::HasNewPose() const
    {
        bool result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::HL2MarkerTracking::IMarkerTracker)->HasNewPose(&result));
        return result;
    }
    template <typename D> auto consume_HL2MarkerTracking_IMarkerTracker<D>::GetObjectPose() const
    {
        uint32_t result_impl_size{};
        double* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::HL2MarkerTracking::IMarkerTracker)->GetObjectPose(&result_impl_size, &result));
        return com_array<double>{ result, result_impl_size, take_ownership_from_abi };
    }
    template <typename D> auto consume_HL2MarkerTracking_IMarkerTracker<D>::GetObjectPoseAndMarkers() const
    {
        uint32_t result_impl_size{};
        double* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::HL2MarkerTracking::IMarkerTracker)->GetObjectPoseAndMarkers(&result_impl_size, &result));
        return com_array<double>{ result, result_impl_size, take_ownership_from_abi };
    }
    template <typename D> auto consume_HL2MarkerTracking_IMarkerTracker<D>::SetParams(int32_t minArea, int32_t maxArea, int32_t binThreshold, float convexity, float circularity, float smoothing, bool contours, bool m_saveIrImages, bool saveDepthImages, bool saveLeftImages, bool saveRightImages, bool saveRaw) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::HL2MarkerTracking::IMarkerTracker)->SetParams(minArea, maxArea, binThreshold, convexity, circularity, smoothing, contours, m_saveIrImages, saveDepthImages, saveLeftImages, saveRightImages, saveRaw));
    }
    template <typename D> auto consume_HL2MarkerTracking_IMarkerTracker<D>::SetJumpSettings(bool doFilter, float threshold, int32_t nFrames) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::HL2MarkerTracking::IMarkerTracker)->SetJumpSettings(doFilter, threshold, nFrames));
    }
    template <typename D> auto consume_HL2MarkerTracking_IMarkerTracker<D>::SetExtrinsicsOffset(array_view<float const> ext) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::HL2MarkerTracking::IMarkerTracker)->SetExtrinsicsOffset(ext.size(), get_abi(ext)));
    }
    template <typename D> auto consume_HL2MarkerTracking_IMarkerTracker<D>::DepthMapUpdated() const
    {
        bool result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::HL2MarkerTracking::IMarkerTracker)->DepthMapUpdated(&result));
        return result;
    }
    template <typename D> auto consume_HL2MarkerTracking_IMarkerTracker<D>::IrImageUpdated() const
    {
        bool result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::HL2MarkerTracking::IMarkerTracker)->IrImageUpdated(&result));
        return result;
    }
    template <typename D> auto consume_HL2MarkerTracking_IMarkerTracker<D>::LfImageUpdated() const
    {
        bool result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::HL2MarkerTracking::IMarkerTracker)->LfImageUpdated(&result));
        return result;
    }
    template <typename D> auto consume_HL2MarkerTracking_IMarkerTracker<D>::RfImageUpdated() const
    {
        bool result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::HL2MarkerTracking::IMarkerTracker)->RfImageUpdated(&result));
        return result;
    }
    template <typename D> auto consume_HL2MarkerTracking_IMarkerTracker<D>::InitializeDepthSensor() const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::HL2MarkerTracking::IMarkerTracker)->InitializeDepthSensor());
    }
    template <typename D> auto consume_HL2MarkerTracking_IMarkerTracker<D>::InitializeStereoCamerasFront() const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::HL2MarkerTracking::IMarkerTracker)->InitializeStereoCamerasFront());
    }
    template <typename D> auto consume_HL2MarkerTracking_IMarkerTracker<D>::StartDepthSensorLoop() const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::HL2MarkerTracking::IMarkerTracker)->StartDepthSensorLoop());
    }
    template <typename D> auto consume_HL2MarkerTracking_IMarkerTracker<D>::StartStereoCamerasFrontLoop() const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::HL2MarkerTracking::IMarkerTracker)->StartStereoCamerasFrontLoop());
    }
    template <typename D> auto consume_HL2MarkerTracking_IMarkerTracker<D>::StopAllSensorDevice() const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::HL2MarkerTracking::IMarkerTracker)->StopAllSensorDevice());
    }
    template <typename D> auto consume_HL2MarkerTracking_IMarkerTracker<D>::SetReferenceCoordinateSystem(winrt::Windows::Perception::Spatial::SpatialCoordinateSystem const& refCoord) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::HL2MarkerTracking::IMarkerTracker)->SetReferenceCoordinateSystem(*(void**)(&refCoord)));
    }
    template <typename D> auto consume_HL2MarkerTracking_IMarkerTrackerFactory<D>::CreateInstance(array_view<float const> geometry, array_view<float const> extrinsicsCorrection, float markerDiameter, bool verbose) const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::HL2MarkerTracking::IMarkerTrackerFactory)->CreateInstance(geometry.size(), get_abi(geometry), extrinsicsCorrection.size(), get_abi(extrinsicsCorrection), markerDiameter, verbose, &value));
        return winrt::HL2MarkerTracking::MarkerTracker{ value, take_ownership_from_abi };
    }
    template <typename D>
    struct produce<D, winrt::HL2MarkerTracking::IMarkerTracker> : produce_base<D, winrt::HL2MarkerTracking::IMarkerTracker>
    {
        int32_t __stdcall GetRawDepthMap(uint32_t* __resultSize, uint16_t** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            std::tie(*__resultSize, *result) = detach_abi(this->shim().GetRawDepthMap());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetProcessedDepthMap(uint32_t* __resultSize, uint8_t** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            std::tie(*__resultSize, *result) = detach_abi(this->shim().GetProcessedDepthMap());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetRawIrImage(uint32_t* __resultSize, uint16_t** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            std::tie(*__resultSize, *result) = detach_abi(this->shim().GetRawIrImage());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetProcessedIrImage(uint32_t* __resultSize, uint8_t** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            std::tie(*__resultSize, *result) = detach_abi(this->shim().GetProcessedIrImage());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetLfImage(int64_t* ts, uint32_t* __resultSize, uint8_t** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            std::tie(*__resultSize, *result) = detach_abi(this->shim().GetLfImage(*ts));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetRfImage(int64_t* ts, uint32_t* __resultSize, uint8_t** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            std::tie(*__resultSize, *result) = detach_abi(this->shim().GetRfImage(*ts));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetLrfImages(int64_t* ts_left, int64_t* ts_right, uint32_t* __resultSize, uint8_t** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            std::tie(*__resultSize, *result) = detach_abi(this->shim().GetLrfImages(*ts_left, *ts_right));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall SetROI(int32_t x, int32_t y, int32_t w) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().SetROI(x, y, w);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall SetDevicePose(uint32_t __poseSize, float* pose) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().SetDevicePose(array_view<float const>(reinterpret_cast<float const *>(pose), reinterpret_cast<float const *>(pose) + __poseSize));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall HasNewPose(bool* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<bool>(this->shim().HasNewPose());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetObjectPose(uint32_t* __resultSize, double** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            std::tie(*__resultSize, *result) = detach_abi(this->shim().GetObjectPose());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetObjectPoseAndMarkers(uint32_t* __resultSize, double** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            std::tie(*__resultSize, *result) = detach_abi(this->shim().GetObjectPoseAndMarkers());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall SetParams(int32_t minArea, int32_t maxArea, int32_t binThreshold, float convexity, float circularity, float smoothing, bool contours, bool m_saveIrImages, bool saveDepthImages, bool saveLeftImages, bool saveRightImages, bool saveRaw) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().SetParams(minArea, maxArea, binThreshold, convexity, circularity, smoothing, contours, m_saveIrImages, saveDepthImages, saveLeftImages, saveRightImages, saveRaw);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall SetJumpSettings(bool doFilter, float threshold, int32_t nFrames) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().SetJumpSettings(doFilter, threshold, nFrames);
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall SetExtrinsicsOffset(uint32_t __extSize, float* ext) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().SetExtrinsicsOffset(array_view<float const>(reinterpret_cast<float const *>(ext), reinterpret_cast<float const *>(ext) + __extSize));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall DepthMapUpdated(bool* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<bool>(this->shim().DepthMapUpdated());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall IrImageUpdated(bool* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<bool>(this->shim().IrImageUpdated());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall LfImageUpdated(bool* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<bool>(this->shim().LfImageUpdated());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall RfImageUpdated(bool* result) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *result = detach_from<bool>(this->shim().RfImageUpdated());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall InitializeDepthSensor() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().InitializeDepthSensor();
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall InitializeStereoCamerasFront() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().InitializeStereoCamerasFront();
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall StartDepthSensorLoop() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().StartDepthSensorLoop();
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall StartStereoCamerasFrontLoop() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().StartStereoCamerasFrontLoop();
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall StopAllSensorDevice() noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().StopAllSensorDevice();
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall SetReferenceCoordinateSystem(void* refCoord) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().SetReferenceCoordinateSystem(*reinterpret_cast<winrt::Windows::Perception::Spatial::SpatialCoordinateSystem const*>(&refCoord));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
    template <typename D>
    struct produce<D, winrt::HL2MarkerTracking::IMarkerTrackerFactory> : produce_base<D, winrt::HL2MarkerTracking::IMarkerTrackerFactory>
    {
        int32_t __stdcall CreateInstance(uint32_t __geometrySize, float* geometry, uint32_t __extrinsicsCorrectionSize, float* extrinsicsCorrection, float markerDiameter, bool verbose, void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::HL2MarkerTracking::MarkerTracker>(this->shim().CreateInstance(array_view<float const>(reinterpret_cast<float const *>(geometry), reinterpret_cast<float const *>(geometry) + __geometrySize), array_view<float const>(reinterpret_cast<float const *>(extrinsicsCorrection), reinterpret_cast<float const *>(extrinsicsCorrection) + __extrinsicsCorrectionSize), markerDiameter, verbose));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
}
WINRT_EXPORT namespace winrt::HL2MarkerTracking
{
}
namespace std
{
#ifndef WINRT_LEAN_AND_MEAN
    template<> struct hash<winrt::HL2MarkerTracking::IMarkerTracker> : winrt::impl::hash_base {};
    template<> struct hash<winrt::HL2MarkerTracking::IMarkerTrackerFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::HL2MarkerTracking::MarkerTracker> : winrt::impl::hash_base {};
#endif
#ifdef __cpp_lib_format
#endif
}
#endif
